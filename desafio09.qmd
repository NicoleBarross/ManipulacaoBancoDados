---
title: "Desafio 09"
author: "Nicole de Barros Silva"
format: 
  html:
    self-contained: true
editor: visual
---

## SQLite - Processamento de Dados em Lote
# SQLite
SQLite é uma aplicação de banco de dados de pouquíssimo impacto e com um potencial de aplicação bastante amplo. Habitualmente, em ambientes de produção que exijam alta performance ou operações mais complexas, SQLite não é a ferramenta padrão de escolha. Para aplicações de menor porte, o SQLite é uma ferramenta de grande importância, pois adequa-se aos padrões de SQL e é multiplataforma.

# Objetivo
Ao fim deste laboratório, você deverá ser capaz de:

Usar a estratégia de leitura por chunks implementada no pacote readr para leitura dos dados de vôos;
Utilizar a função SideEffectChunkCallback$new() para depositar os dados do arquivo diretamente no banco de dados (sem devolver resultados para o usuário);

# Recomendações
Não utilize o servidor jupyter.ime.unicamp.br para executar esta atividade;
Instale os pacotes readr e RSQLite, se necessário. A sugestão é empregar install.packages(c("readr", "RSQLite"), dep=TRUE, type='win.binary').
Atente para mensagens de erro adicionais (como outros pacotes faltantes) e instale-os conforme requerido.

```{r}
# Instala e carrega os pacotes readr e RSQLite
#install.packages(c("readr", "RSQLite"), dep=TRUE, type='win.binary')
library(readr)
library(RSQLite)
```


# Atividades

1. Crie um arquivo de banco de dados em SQLite chamado voos.sqlite3. (Dica: o comando dbConnect() se conecta num banco de dados se o arquivo apontado existir ou cria um novo, caso o arquivo não exista.)
```{r}
# Cria o banco SQLite
con <- dbConnect(SQLite(), "voos.sqlite3")
```

2. Leia os arquivos airlines.csv e airports.csv. Deposite o conteúdo de cada um destes arquivos nas tabelas, respectivamente, airlines e airports. Utilize o comando dbWriteTable() para isso.
```{r}
# Lê os arquivos CSV
airlines <- read_csv("airlines.csv")
airports <- read_csv("airports.csv")

# Cria as tabelas 'airlines' e 'airports' no banco
dbWriteTable(con, "airlines", airlines, overwrite = TRUE)
dbWriteTable(con, "airports", airports, overwrite = TRUE)
```

3. Crie uma função chamada lerDados contendo 2 argumentos, input e pos. A função deve apresentar ao usuário uma mensagem de progresso da leitura do arquivo flights.csv (utilize o comando message()), aos moldes do apresentado abaixo. A função deve salvar apenas os vôos que partiram ou chegaram aos seguintes aeroportos BWI, MIA, SEA, SFO e JFK, numa tabela chamada flights. Observe que a função não deve retornar nada para o usuário, deve apenas gravar a tabela obtida do chunk no banco de dados. (Dica: utilize o comando dbWriteTable() e estude como o argumento append deve ser utilizado para permitir que os chunks intermediários sejam adicionados ao fim da tabela.)

```{r}
# Define a função 'lerDados' com argumentos 'input' (chunk de dados) e 'pos' (posição do chunk
lerDados <- function(input, pos) {
# Exibe mensagem de progresso mostrando a linha atual lida
  message("Leitura atingiu a linha ", pos)
  
# Filtra apenas os voos cuja origem ou destino esteja entre BWI, MIA, SEA, SFO ou JFK
  subset <- input[input$ORIGIN_AIRPORT %in% c("BWI","MIA","SEA","SFO","JFK") |
                  input$DESTINATION_AIRPORT %in% c("BWI","MIA","SEA","SFO","JFK"), ]
  
  # Escreve no banco (se for o primeiro chunk, cria a tabela 'flights' no banco; senão, apenas adiciona os dados filtrados ao final da tabela existente)
  if (pos == 0) {
    dbWriteTable(con, "flights", subset, overwrite = TRUE)
  } else {
    dbWriteTable(con, "flights", subset, append = TRUE)
  }
}
```

4. Leia o arquivo flights.csv, restringindo-se às colunas YEAR, MONTH, DAY, AIRLINE, FLIGHT_NUMBER, ORIGIN_AIRPORT, DESTINATION_AIRPORT e ARRIVAL_DELAY, e aplique a função lerDados() criada acima. Observe, novamente, que a função lerDados() não retorna nada para o usuário. Por isso, a função de callback a ser utilizada é SideEffectChunkCallback$new(). Leia 100 mil registros por vez.
```{r}
# Define apenas as colunas que queremos ler, especificando seu tipo
colunas <- cols_only(
  YEAR = col_integer(),
  MONTH = col_integer(),
  DAY = col_integer(),
  AIRLINE = col_character(),
  FLIGHT_NUMBER = col_integer(),
  ORIGIN_AIRPORT = col_character(),
  DESTINATION_AIRPORT = col_character(),
  ARRIVAL_DELAY = col_double()
)

# Cria o callback que chama a função 'lerDados' a cada chunk lido
callback <- SideEffectChunkCallback$new(lerDados)
# Faz a leitura em chunks do arquivo CSV, definindo o tamanho do chunk em 100 mil linhas
read_csv_chunked(
  unz("flights.csv.zip", "flights.csv"),
  callback = callback,
  chunk_size = 100000,
  col_types = colunas
)
```



5. Acesse o banco de dados e, por meio de uma chamada em SQL, apresente o tempo médio de atraso de chegada por aeroporto de destino, a sigla do aeroporto, o nome completo do aeroporto e o nome completo da companhia aérea. Ordene o resultado (na mesma chamada de SQL) por ordem decrescente deste atraso médio (i.e., o primeiro registro deve ser o aeroporto que tem o maior tempo de atraso na chegada). Atente para o fato de que o mesmo nome de coluna pode acontecer em diferentes tabelas.

```{r}
query <- "
SELECT 
    f.DESTINATION_AIRPORT AS sigla_aeroporto,
    ap.AIRPORT AS nome_aeroporto,
    al.AIRLINE AS nome_companhia,
    AVG(f.ARRIVAL_DELAY) AS atraso_medio
FROM flights f
JOIN airports ap ON f.DESTINATION_AIRPORT = ap.IATA_CODE
JOIN airlines al ON f.AIRLINE = al.IATA_CODE
GROUP BY f.DESTINATION_AIRPORT, ap.AIRPORT, al.AIRLINE
ORDER BY atraso_medio DESC
"
#Define a consulta SQL que será executada no banco
#Seleciona a sigla do aeroporto de destino da tabela flights
#Seleciona o nome completo do aeroporto da tabela airports
#Seleciona o nome completo da companhia aérea da tabela airlines
#Calcula a média do atraso de chegada dos voos
#Define a tabela flights como tabela principal com alias 'f'
#Faz join com a tabela airports usando o código IATA
#Faz join com a tabela airlines usando o código da companhia aérea
#Agrupa os resultados por aeroporto de destino e companhia aérea
#Ordena o resultado em ordem decrescente do atraso médio

resultado <- dbGetQuery(con, query) # Executa a consulta SQL e salva o resultado em um data frame no R
resultado
```

```{r}
# Desconecta o banco de dados
dbDisconnect(con)
```


```{r}
# Registra quando o arquivo foi compilado
cat(paste0("Este HTML foi gerado em: ", Sys.time()))
```

